import express from 'express';
import { PrismaClient } from '@prisma/client';
import { authMiddleware } from '../middleware/auth.js';

const router = express.Router();
const prisma = new PrismaClient();

// =====================================================
// STORED PROCEDURE ENDPOINTS
// =====================================================

// Get Championship Standings (direct query - bypass stored procedure for now)
router.get('/championship-standings/:seasonId/:type', authMiddleware, async (req, res) => {
  try {
    const { seasonId, type } = req.params;
    
    console.log('Fetching standings for:', { seasonId, type });
    
    if (!['driver', 'team'].includes(type)) {
      return res.status(400).json({ error: 'Type must be "driver" or "team"' });
    }

    const seasonIdInt = parseInt(seasonId);
    console.log('Season ID:', seasonIdInt, 'Type:', type);

    // Use direct query instead of stored procedure for now
    if (type === 'driver') {
      const standings = await prisma.$queryRaw`
        SELECT 
          d.id,
          d.name as driverName,
          d.number,
          t.name as teamName,
          t.color as teamColor,
          COALESCE(SUM(rr.points), 0) as totalPoints,
          COUNT(CASE WHEN rr.position = 1 THEN 1 END) as wins,
          COUNT(CASE WHEN rr.position <= 3 THEN 1 END) as podiums,
          COUNT(rr.id) as racesParticipated
        FROM Driver d
        LEFT JOIN Team t ON d.teamId = t.id
        LEFT JOIN RaceResult rr ON d.id = rr.driverId
        LEFT JOIN Race r ON rr.raceId = r.id
        WHERE r.seasonId = ${seasonIdInt} OR r.seasonId IS NULL
        GROUP BY d.id, d.name, d.number, t.name, t.color
        HAVING totalPoints > 0 OR racesParticipated > 0
        ORDER BY totalPoints DESC, wins DESC, podiums DESC
      `;

      // Convert BigInt to Number for JSON serialization
      const serialized = standings.map(row => ({
        ...row,
        totalPoints: Number(row.totalPoints),
        wins: Number(row.wins),
        podiums: Number(row.podiums),
        racesParticipated: Number(row.racesParticipated)
      }));

      console.log('Driver standings:', serialized);

      res.json({
        seasonId: seasonIdInt,
        type,
        standings: serialized
      });
    } else {
      // Team standings
      const standings = await prisma.$queryRaw`
        SELECT 
          t.id,
          t.name as teamName,
          t.fullName,
          t.color,
          COALESCE(SUM(rr.points), 0) as totalPoints,
          COUNT(CASE WHEN rr.position = 1 THEN 1 END) as wins,
          COUNT(CASE WHEN rr.position <= 3 THEN 1 END) as podiums,
          COUNT(DISTINCT rr.raceId) as racesParticipated
        FROM Team t
        LEFT JOIN RaceResult rr ON t.id = rr.teamId
        LEFT JOIN Race r ON rr.raceId = r.id
        WHERE r.seasonId = ${seasonIdInt} OR r.seasonId IS NULL
        GROUP BY t.id, t.name, t.fullName, t.color
        HAVING totalPoints > 0 OR racesParticipated > 0
        ORDER BY totalPoints DESC, wins DESC, podiums DESC
      `;

      // Convert BigInt to Number for JSON serialization
      const serialized = standings.map(row => ({
        ...row,
        totalPoints: Number(row.totalPoints),
        wins: Number(row.wins),
        podiums: Number(row.podiums),
        racesParticipated: Number(row.racesParticipated)
      }));

      console.log('Team standings:', serialized);

      res.json({
        seasonId: seasonIdInt,
        type,
        standings: serialized
      });
    }
  } catch (error) {
    console.error('Championship standings error:', error);
    console.error('Error details:', error.message);
    console.error('Error code:', error.code);
    console.error('Stack trace:', error.stack);
    res.status(500).json({ error: 'Failed to fetch championship standings', details: error.message });
  }
});

// Generate Race Report (direct queries - stored procedure exists but bypassed for reliability)
router.get('/race-report/:raceId', authMiddleware, async (req, res) => {
  try {
    const { raceId } = req.params;
    const raceIdInt = parseInt(raceId);

    console.log('Generating race report for race ID:', raceIdInt);
    
    // Get race basic info
    const raceInfo = await prisma.$queryRaw`
      SELECT 
        r.id,
        r.name AS raceName,
        r.date,
        r.status,
        c.name AS circuitName,
        c.location,
        c.country,
        c.length AS circuitLength,
        c.laps,
        s.year AS season,
        COUNT(DISTINCT rr.id) AS totalFinishers,
        COUNT(DISTINCT ri.id) AS totalIncidents,
        COUNT(DISTINCT pa.id) AS totalPenalties
      FROM Race r
      INNER JOIN Circuit c ON r.circuitId = c.id
      INNER JOIN Season s ON r.seasonId = s.id
      LEFT JOIN RaceResult rr ON r.id = rr.raceId
      LEFT JOIN RaceIncident ri ON r.id = ri.raceId
      LEFT JOIN PenaltyAssignment pa ON ri.id = pa.incidentId
      WHERE r.id = ${raceIdInt}
      GROUP BY r.id, r.name, r.date, r.status, c.name, c.location, c.country, c.length, c.laps, s.year
    `;

    // Get race results
    const results = await prisma.$queryRaw`
      SELECT 
        rr.position,
        d.name AS driverName,
        d.number,
        t.name AS teamName,
        rr.time,
        rr.points,
        rr.penalty,
        rr.fastestLap
      FROM RaceResult rr
      INNER JOIN Driver d ON rr.driverId = d.id
      INNER JOIN Team t ON rr.teamId = t.id
      WHERE rr.raceId = ${raceIdInt}
      ORDER BY rr.position
    `;

    // Get incidents
    const incidents = await prisma.$queryRaw`
      SELECT 
        ri.lap,
        d.name AS driverName,
        t.name AS teamName,
        ri.description,
        p.type AS penaltyType,
        p.value AS penaltyValue,
        pa.status AS penaltyStatus,
        u.name AS stewardName
      FROM RaceIncident ri
      INNER JOIN Driver d ON ri.driverId = d.id
      INNER JOIN Team t ON d.teamId = t.id
      LEFT JOIN Penalty p ON ri.penaltyId = p.id
      LEFT JOIN PenaltyAssignment pa ON ri.id = pa.incidentId
      LEFT JOIN User u ON pa.stewardId = u.id
      WHERE ri.raceId = ${raceIdInt}
      ORDER BY ri.lap
    `;

    // Convert BigInt to Number for JSON serialization
    const serializedRaceInfo = raceInfo[0] ? {
      ...raceInfo[0],
      totalFinishers: Number(raceInfo[0].totalFinishers),
      totalIncidents: Number(raceInfo[0].totalIncidents),
      totalPenalties: Number(raceInfo[0].totalPenalties),
      circuitLength: Number(raceInfo[0].circuitLength),
      laps: Number(raceInfo[0].laps),
      season: Number(raceInfo[0].season)
    } : {};

    const serializedResults = results.map(row => ({
      ...row,
      position: Number(row.position),
      number: Number(row.number),
      points: Number(row.points)
    }));

    const serializedIncidents = incidents.map(row => ({
      ...row,
      lap: Number(row.lap)
    }));

    console.log('Race report generated successfully');

    res.json({
      raceId: raceIdInt,
      raceInfo: serializedRaceInfo,
      results: serializedResults,
      incidents: serializedIncidents
    });
    
  } catch (error) {
    console.error('Race report error:', error);
    console.error('Error details:', error.message);
    res.status(500).json({ error: 'Failed to generate race report', details: error.message });
  }
});

// =====================================================
// FUNCTION ENDPOINTS
// =====================================================

// Calculate race time with penalties (calls function)
router.get('/race-time-with-penalties/:raceId/:driverId', authMiddleware, async (req, res) => {
  try {
    const { raceId, driverId } = req.params;

    // Call function using raw SQL
    const result = await prisma.$queryRawUnsafe(
      `SELECT CalculateRaceTimeWithPenalties(${parseInt(raceId)}, ${parseInt(driverId)}) AS totalTime`
    );

    res.json({
      raceId: parseInt(raceId),
      driverId: parseInt(driverId),
      totalTime: result[0].totalTime
    });
  } catch (error) {
    console.error('Calculate race time error:', error);
    res.status(500).json({ error: 'Failed to calculate race time with penalties' });
  }
});

// Get driver performance rating (calls function)
router.get('/driver-performance/:driverId', authMiddleware, async (req, res) => {
  try {
    const { driverId } = req.params;

    // Call function using raw SQL
    const result = await prisma.$queryRawUnsafe(
      `SELECT GetDriverPerformanceRating(${parseInt(driverId)}) AS rating`
    );

    res.json({
      driverId: parseInt(driverId),
      rating: result[0].rating
    });
  } catch (error) {
    console.error('Driver performance rating error:', error);
    res.status(500).json({ error: 'Failed to get driver performance rating' });
  }
});

// =====================================================
// ANALYTICS QUERIES
// =====================================================

// Get penalty statistics
router.get('/penalty-statistics', authMiddleware, async (req, res) => {
  try {
    // Get penalty counts by type
    const penaltyTypes = await prisma.$queryRaw`
      SELECT 
        p.type,
        COUNT(*) as count
      FROM Penalty p
      INNER JOIN RaceIncident ri ON p.id = ri.penaltyId
      GROUP BY p.type
      ORDER BY count DESC
    `;

    // Get drivers with most penalties
    const driverPenalties = await prisma.$queryRaw`
      SELECT 
        d.id,
        d.name,
        d.number,
        t.name as teamName,
        COUNT(ri.id) as penaltyCount
      FROM Driver d
      INNER JOIN RaceIncident ri ON d.id = ri.driverId
      INNER JOIN Team t ON d.teamId = t.id
      WHERE ri.penaltyId IS NOT NULL
      GROUP BY d.id, d.name, d.number, t.name
      ORDER BY penaltyCount DESC
      LIMIT 10
    `;

    // Convert BigInt to Number for JSON serialization
    const serializedPenaltyTypes = penaltyTypes.map(row => ({
      ...row,
      count: Number(row.count)
    }));

    const serializedDriverPenalties = driverPenalties.map(row => ({
      ...row,
      number: Number(row.number),
      penaltyCount: Number(row.penaltyCount)
    }));

    res.json({
      penaltyTypes: serializedPenaltyTypes,
      driverPenalties: serializedDriverPenalties
    });
  } catch (error) {
    console.error('Penalty statistics error:', error);
    res.status(500).json({ error: 'Failed to fetch penalty statistics' });
  }
});

// Get drivers with incidents
router.get('/drivers-with-incidents', authMiddleware, async (req, res) => {
  try {
    const drivers = await prisma.$queryRaw`
      SELECT 
        d.id,
        d.name,
        d.number,
        t.name as teamName,
        t.color as teamColor,
        COUNT(ri.id) as incidentCount,
        COUNT(CASE WHEN ri.penaltyId IS NOT NULL THEN 1 END) as penaltyCount
      FROM Driver d
      INNER JOIN RaceIncident ri ON d.id = ri.driverId
      INNER JOIN Team t ON d.teamId = t.id
      GROUP BY d.id, d.name, d.number, t.name, t.color
      ORDER BY incidentCount DESC
    `;

    // Convert BigInt to Number for JSON serialization
    const serialized = drivers.map(row => ({
      ...row,
      number: Number(row.number),
      incidentCount: Number(row.incidentCount),
      penaltyCount: Number(row.penaltyCount)
    }));

    res.json(serialized);
  } catch (error) {
    console.error('Drivers with incidents error:', error);
    res.status(500).json({ error: 'Failed to fetch drivers with incidents' });
  }
});

export default router;
